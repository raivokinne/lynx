let createSet = fn() {
    let items = {}
    let count = 0  // Track size manually

    return {
        "add": fn(item) {
            if items[item] != true {
                items[item] = true
                count = count + 1
            }
        },
        "has": fn(item) {
            return items[item] == true
        },
        "remove": fn(item) {
            if items[item] == true {
                items[item] = null
                count = count - 1
            }
        },
        "size": fn() {
            return count
        },
        "clear": fn() {
            items = {}
            count = 0
        }
    }
}

let createQueue = fn() {
    let items = []

    return {
        "enqueue": fn(item) {
            items = items.push(item)
        },
        "dequeue": fn() {
            if items.len() == 0 {
                return null
            }
            let item = items.first()
            items = items.rest()
            return item
        },
        "front": fn() {
            if items.len() == 0 {
                return null
            }
            return items.first()
        },
        "back": fn() {
            if items.len() == 0 {
                return null
            }
            return items[items.len() - 1]
        },
        "size": fn() {
            return items.len()
        },
        "isEmpty": fn() {
            return items.len() == 0
        }
    }
}

let createMap = fn() {
    let keys = []
    let values = []

    return {
        "set": fn(key, value) {
            let index = -1
            let i = 0
            while i < keys.len() {
                if keys[i] == key {
                    index = i
                    break
                }
                i = i + 1
            }
            if index >= 0 {
                values[index] = value
            } else {
                keys = keys.push(key)
                values = values.push(value)
            }
        },
        "get": fn(key) {
            let i = 0
            while i < keys.len() {
                if keys[i] == key {
                    return values[i]
                }
                i = i + 1
            }
            return null
        },
        "has": fn(key) {
            let i = 0
            while i < keys.len() {
                if keys[i] == key {
                    return true
                }
                i = i + 1
            }
            return false
        },
        "remove": fn(key) {
            let i = 0
            while i < keys.len() {
                if keys[i] == key {
                    // Remove from both arrays
                    let newKeys = []
                    let newValues = []
                    let j = 0
                    while j < keys.len() {
                        if j != i {
                            newKeys = newKeys.push(keys[j])
                            newValues = newValues.push(values[j])
                        }
                        j = j + 1
                    }
                    keys = newKeys
                    values = newValues
                    return true
                }
                i = i + 1
            }
            return false
        },
        "keys": fn() {
            return keys
        },
        "values": fn() {
            return values
        },
        "size": fn() {
            return keys.len()
        },
        "clear": fn() {
            keys = []
            values = []
        }
    }
}

// Stack implementation (since you have queue)
let createStack = fn() {
    let items = []

    return {
        "push": fn(item) {
            items = items.push(item)
        },
        "pop": fn() {
            if items.len() == 0 {
                return null
            }
            let item = items[items.len() - 1]
            // Remove last element
            let newItems = []
            let i = 0
            while i < items.len() - 1 {
                newItems = newItems.push(items[i])
                i = i + 1
            }
            items = newItems
            return item
        },
        "peek": fn() {
            if items.len() == 0 {
                return null
            }
            return items[items.len() - 1]
        },
        "size": fn() {
            return items.len()
        },
        "isEmpty": fn() {
            return items.len() == 0
        }
    }
}
